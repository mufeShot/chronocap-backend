# Project Explanation (Backend Functionality Overview)

## 1. Authentication & Sessions
### What it is
State-less authentication implemented with short‑lived access tokens and (optionally) longer‑lived refresh tokens stored server‑side (DB) as a hashed string (currently the field `refreshToken` in `User`).

### How it works (flow)
1. /auth/register: Validates DTO (class-validator), hashes password with bcrypt (cost defined by default salt rounds in service), creates User row (email unique constraint enforced by Prisma + DB). Returns a freshly minted access + (optionally) refresh token pair.
2. /auth/login: Looks up user by email, compares bcrypt hash; on success issues new JWT access (payload: userId, email) signed with `JWT_SECRET` & `JWT_EXPIRES` TTL. The refresh token (if used) is stored/updated in the `refreshToken` column (hashing recommended— to be added).
3. /auth/me: Protected by `JwtAuthGuard`; extracts `req.user` from validated JWT using `JwtStrategy` (Passport strategy reading Authorization Bearer header). Returns basic profile data.
4. /auth/refresh: Accepts refresh token (body/header) → validates against stored hash (currently plain, improvement: hash + rotate). Issues new pair & replaces stored refresh token (rotation invalidates old token).
5. /auth/logout: Nullifies stored refreshToken to invalidate future refresh attempts.

### Implementation points
* JwtStrategy uses `passport-jwt` with secret from env; attaches decoded payload to `req.user`.
* `JwtAuthGuard` extends Nest AuthGuard to reject invalid/missing tokens (401).
* `OptionalJwtAuthGuard` (custom) allows request through without token— enabling adaptive responses (public vs owner) while populating `req.user` when available.
* Error handling: invalid credentials return 401; duplicate email relies on DB unique error (should be translated— improvement area).
* Security enhancements pending: refresh token hashing, brute force protection, rate limiting login.

### Data integrity
User password cannot be retrieved (one‑way hash). Refresh token uniqueness guaranteed by unique column (enforces single active refresh token per user — token rotation semantics).

## 2. Capsules Domain
### Model (Prisma / DB)
```
Capsule { id Int PK; userId FK(User); title String; content String; isPublic Bool; unlockAt DateTime; images String[]; createdAt; updatedAt }
```
`images` stores either relative paths (local driver) or absolute public URLs (Supabase driver). Keeping a string array simplifies reads (no join) at the cost of duplicate string storage— acceptable trade‑off given low cardinality per capsule.

### CRUD flows
* Create: DTO validated; `unlockAt` parsed to Date; `images` resolved by Storage layer (see section 5). Prisma create executed inside single call (no transaction needed unless we later atomically associate more relations). Returns capsule with DB timestamps.
* Read (owner list): Pagination via skip/take numeric parameters with bounds; ordered by `createdAt desc` to show newest first.
* Adaptive Read (detail): Single query for full capsule (with user now included). Logic branches based on ownership & lock state.
* Update: Ownership assertion first; optional partial update fields; `unlockAt` only re-parsed when provided.
* Delete: Ownership check then delete; (TODO: storage cleanup of image objects when Supabase driver used).

### Validation / edge cases
* unlockAt in past still allowed (interpreted as immediately unlocked)— improvement: reject past dates if undesired.
* images length currently unconstrained aside from Multer cap (10). Consider DB constraint or application validation.
* Large content: rely on Postgres TEXT; consider size limit to prevent abuse.

## 3. Public Exposure & Lock Logic
### Lock evaluation
`locked = unlockAt > now`. `secondsUntilUnlock` computed as CEIL((unlockAt - now)/1000) when locked else 0. `unlocked = !locked` for client convenience (boolean redundancy intentionally trading a few bytes for simpler front-end logic and filtering).

### Public list
Always returns both locked and unlocked (isPublic=true). Locked entries have `content=null` and `images=[]` to avoid early disclosure while preserving schema shape (prevents UI null reference errors). This “structural masking” is explicit (fields present but inert) rather than omission, aiding predictable rendering.

### Adaptive route
Centralizes branching to reduce duplication: same endpoint suffices for owner preview, public consumption, and protection of private capsules. Owner bypass avoids exfiltration timing issues by simply returning full record; no need for second call after unlock event.

## 4. Creator Information
Service queries include `user { id email name }`. Controller maps to `creator` field in response (rather than nesting raw Prisma relation) to decouple external API from internal model naming, permitting future relation renaming without breaking clients.

Privacy consideration: Email exposure to public consumers may be undesirable. Add a conditional to hide or hash later; currently acceptable for initial iteration.

## 5. Image Storage Abstraction
### Pipeline (detailed)
1. Controller uses a single Multer memory storage interceptor (uniform for both drivers) so files enter as buffers.
2. `StorageService.storeCapsuleImages()` branches on `driver`:
  * local → ensures `uploads/capsule-images` exists, writes buffer to disk with unique time/random suffix, constructs relative path + optional absolute URL.
  * supabase → initializes client with service role key, uploads buffer to bucket path `capsule-images/<timestamp>-<random>.<ext>`, retrieves public URL via `getPublicUrl`.
3. Returned list of URLs persisted into capsule `images` field.

### Error handling
* Missing buffer (should not happen with memory storage) logged & skipped.
* Supabase upload error logged (non-fatal) continuing other files.
* If all fail, empty array stored— capsule still created (trade-off: partial success; could revert with transactional semantics across storage + DB in future).

### Security trade-offs
* Public bucket simplifies direct embedding but allows URL discovery (if path guessed). Enhancement: switch to private bucket + signed URLs at read time.
* Service role key currently required server-side only; never sent to client.

### Future enhancements
* Object key storage (instead of full URL) + dynamic URL generation for CDN changes.
* Deduplicate identical uploads via hash (avoid duplicate storage cost).
* Automatic thumbnail + WebP generation and size validation (reject > e.g. 5MB).

## 6. Environment & Configuration
`ConfigModule.forRoot({ envFilePath: [`.env.${NODE_ENV}`, '.env'] })` ensures environment-specific file first, then base fallback for any unspecified keys. Scripts set `NODE_ENV` with cross-env. Production secrets (service role key, DB password) should NOT be committed; rotate immediately if leaked. Prisma CLI operations read only root `.env` unless `DATABASE_URL` env var is overridden— hence manual override needed to target Supabase during migrations.

## 7. Database Layer (Prisma)
### Migration workflow
* Dev schema changes: `prisma migrate dev --name <change>` (generates SQL + updates client).
* Prod deployment: `prisma migrate deploy` (applies unapplied SQL migrations sequentially, deterministic).
* `P2021` earlier indicated missing tables (migrations not applied) when pointing `DATABASE_URL` at a fresh Supabase DB.

### Query patterns
* `$transaction([count, findMany])` pattern ensures count + page list reflect same snapshot (though not fully serializable; acceptable here). Consider `take + 1` strategy for infinite scroll later.
* Include for user relation only where necessary to avoid over-fetching.

## 8. Security & Access Control
Additional considerations:
* JWT secret length— should be strong (recommend >= 32 bytes random). Current placeholder must be rotated before prod.
* Rate limiting & IP throttling not yet implemented (DoS risk). Nest middleware or API gateway layer recommended.
* No CSRF concern on pure API + Bearer tokens; ensure CORS restricted to trusted origins.
* Potential enumeration: Private capsule 403 reveals existence. Alternative: return 404 to hide existence (decision trade-off). Adaptive route currently reveals difference; may adjust.

## 9. Time Lock Mechanics
Edge cases:
* Clock skew: If server clock drifts, unlock timing inaccurate. Mitigation: periodic NTP sync or store unlock decisions anchored to UTC.
* Negative seconds: Guarded by max/conditional logic.
* Potential future: progressive reveal (partial content before unlock) or scheduled notifications (queue integration placeholder currently available via `QueueModule`).

## 10. Error Handling & Responses
Enhancements pending: Global exception filter mapping Prisma errors (unique constraint, not found) to domain-specific messages; structured error object shape (code, message, details) for better client handling; logging correlation IDs.

## 11. Upload Pipeline (Runtime Flow)
1. Request (multipart) hits controller.
2. Multer (memory) parses files.
3. StorageService selects driver:
   - local → writes file, builds URL.
   - supabase → uploads buffer, obtains public URL.
4. Returned URL list saved in DB images[].
5. Response payload assembled with lock and creator info.

## 12. Public vs Owner Data Integrity
- Public list never sends content/images for locked items.
- Owner list always unmasked—no extra round trips needed for dashboard open.
- Single adaptive detail endpoint reduces duplication and frontend branching.

## 13. Extensibility Points (Outlined)
Detailed roadmap:
* Signed URLs: Replace permanent public links with short-lived (e.g., 60s) signed URLs returned on each request → prevents link scraping longevity.
* Background cleanup: On delete, enqueue job to remove each object (Supabase `remove` API). Retry/backoff strategy for transient failures.
* Object key normalization: Store only `capsule-images/<file>` → compute full URL at read; centralize base changes.
* Media processing: On upload, generate derivative sizes (thumb, medium) store with suffix naming; DB holds JSON {original, thumb, ...} or separate arrays.
* Audit trail: Log view events (especially first unlock) for analytics & integrity.
* Versioning: Maintain historical edits (new table CapsuleVersion). Owner can time-travel snapshots.

## 14. Operational Notes
- Production run: npm run build → npm run start:prod (Supabase driver active).
- Dev run: npm run start:dev (local driver).
- Migration prerequisite before first prod usage (ensures User & Capsule tables).
- Rotation guidance provided for leaked service role key.

## 15. Limitations (Current)
Additional limitations:
* Lack of integration tests for storage & auth flows (only unit/e2e placeholders).
* No graceful shutdown hook ensuring in-flight uploads complete (add `beforeApplicationShutdown`).
* No structured logging (JSON) for production observability.
* Minimal validation for unlockAt (could accept invalid formats— currently relying on Date parse success).

## 16. Rationale Summary
### Design trade-offs explained
* Single adaptive endpoint vs multiple: reduces round trips & divergent caching behavior; complexity concentrated in server logic where it is testable.
* MemoryStorage for all drivers: Avoids duplicating two Multer configurations & eliminates intermediate disk writes when using cloud (saves IO + cleanup complexity). Slightly higher RAM usage per request— mitigated by limiting max file count & size (to add).
* Public bucket initial phase: Minimizes implementation time while validating functional requirements; lowers barrier for frontend embedding. Security remediation path (private + signed) clearly defined to upgrade later without changing DB schema if we store object keys.
* Including user relation at query time: Avoids n+1 queries; small overhead acceptable because cardinality (capsules per page) limited; only selected columns fetched.
* String[] for images: Simplicity & atomic update; alternative (Image table) adds complexity only needed if metadata per image (EXIF, size) becomes necessary.

### Future evolution path
1. Introduce object key abstraction & signed URLs.
2. Add cleanup + lifecycle policies (delete orphaned images, retention rules).
3. Implement event sourcing (unlock events, view events) for analytics & auditing.
4. Add background job processing (thumbnailing) via QueueModule.
5. Harden security (RLS for storage, hashed refresh tokens, rate limiting, content scanning).

---
This expanded documentation details both current implementation specifics and intentional trade-offs, forming the basis for the redundancy & long-term preservation focus (next phase: redundancy strategies for storage + multi-region replication, integrity hashes, migration/versioning of data formats).

## 17. Module Inventory (NestJS Architecture)
Each module encapsulates a bounded context or cross‑cutting concern. Overview:

1. `AppModule`
  - Root composition module. Imports and wires configuration + all feature modules.
  - Future: central place to register global filters (Prisma error mapper), rate limiters.
2. `AuthModule`
  - Providers: `AuthService`, `JwtStrategy`.
  - Controllers: `AuthController`.
  - Exports nothing externally (all interaction via HTTP endpoints; could export a helper for internal user context resolution if needed later).
3. `UsersModule`
  - Encapsulates user CRUD / lookup. Current implementation minimal (service + controller skeleton) — mostly leveraged indirectly via Auth.
4. `CapsulesModule`
  - Domain logic for time capsules (controller(s) + service). Provides both authenticated and public controllers splitting responsibilities but sharing service.
5. `StorageModule`
  - Abstracts binary persistence. Exports `StorageService` so other modules can inject it. Potential home for additional providers (e.g., `ImageProcessorService`).
6. `CommonModule`
  - Shared utilities: `PrismaService`, future guards/interceptors/pipes. Keeps cross‑cutting logic consolidated.
7. `QueueModule`
  - Placeholder for background job infrastructure. Currently may just expose a service stub; will later integrate BullMQ / Redis or Cloud task queue.
8. `MailModule`
  - Email dispatch & webhook handling (e.g., for delivery events). Webhook controller receives provider callbacks (currently scaffolded).
9. `PdfModule`
  - Generation of PDF exports (e.g., printable capsule summary). Currently skeleton; plan to integrate `pdf-lib` or headless Chromium for rendering.
10. `ResolverModule`
   - Potentially for resolving share links / short codes to underlying capsules (e.g., public share token endpoint). Presently a thin controller.
11. `Storage` vs `Prisma` boundary
   - Binary assets never stored in DB (only references). DB remains lean and replicable; object storage handles scale.

This modular segmentation enables selective replacement (e.g., swap StorageModule implementation, add test doubles) and isolates blast radius for changes.

## 18. Request Lifecycle (Detailed Flow)
Example: Authenticated capsule creation with image upload (Supabase driver):
1. TCP connection accepted (Node HTTP server created by Nest bootstrap).
2. Nest global middleware (if any added later) executes (currently minimal — static assets & CORS setup outside pure middleware path).
3. Routing: `POST /capsules` matches `CapsulesController.create()` decorated with `@UseGuards(JwtAuthGuard)` and `@UseInterceptors(FilesInterceptor(...))` (conceptually; actual interceptor used).
4. Multer intercepts request stream, buffers up to configured file size limit (currently default; future explicit limit) into memory Buffers.
5. Guards executed: `JwtAuthGuard` validates Authorization header → Passport JwtStrategy decodes JWT (sync signature verify) → attaches payload to `req.user`.
6. Validation pipe transforms & validates DTO (class-transformer / class-validator) — invalid input throws `BadRequestException` (400) before controller logic.
7. Controller method invoked with injected `StorageService` & parsed files array.
8. Storage layer path:
  - Driver check (enum string).
  - For Supabase: instantiate (or reuse) client; sequential or Promise.all uploads of buffers (currently sequential or naive; improvement: parallel with concurrency cap) to bucket.
9. Returned URLs merged into `CreateCapsuleDto` field `images`.
10. `CapsulesService.create()` executes Prisma `capsule.create` with mapped data & relation connect to user.
11. Prisma client constructs parameterized SQL; sends over pooled connection to Postgres (Supabase) via pg driver.
12. Response object normalization: add creator, lock metadata.
13. Nest serializes JS object to JSON; sets status code 201.
14. Response written to socket; Node event loop returns to idle.

Latency sources enumerated for optimization: JWT verification (~micro to low ms), image uploads (dominant), DB insert (low ms). Potential parallelization: start DB insert after obtaining all storage results— currently sequential implicitly. Advanced optimization: optimistic create then outbox pattern for eventual image association (not needed yet).

## 19. Environment Variables Reference
| Variable | Purpose | Example | Notes |
|---------|---------|---------|-------|
| NODE_ENV | Environment selection (dev/prod) | development | Drives env file selection & storage driver default |
| DATABASE_URL | Prisma connection string | postgres://... | Must point to Supabase in prod |
| STORAGE_DRIVER | Selects storage backend | local / supabase | Required; fallback could be local |
| SUPABASE_URL | Supabase project URL | https://xyz.supabase.co | Used by supabase-js init |
| SUPABASE_SERVICE_ROLE_KEY | Server privileged key | (secret) | Never expose to clients; rotate if leaked |
| SUPABASE_BUCKET | Target storage bucket name | time-capsule | Must exist & (currently) public |
| JWT_SECRET | HMAC signing secret | (32+ bytes) | Consider env-specific rotation schedule |
| JWT_EXPIRES | Access token TTL | 15m | Short to limit blast radius |
| REFRESH_TOKEN_EXPIRES | Refresh TTL | 30d | If implementing hashed refresh tokens |
| PUBLIC_BASE_URL | Absolute base for constructing asset URLs (local mode) | http://localhost:3000 | Ensures correct links behind proxies |
| PORT | HTTP server port | 3000 | Optional; default inside main.ts |
| LOG_LEVEL | Planned logging verbosity | info/debug | To integrate with structured logger |

Future: Introduce `IMAGE_MAX_SIZE_MB`, `RATE_LIMIT_*`, `REDIS_URL` (for queue + cache), `SIGNING_KEY_ROTATION_INTERVAL_DAYS`.

## 20. Prisma Schema Deep Dive
Key design decisions inside `schema.prisma` (not shown here, inferred):
* Models: `User`, `Capsule` (+ possibly others later). Indices: implicit primary keys (id). Consider composite index `(userId, createdAt desc)` for faster owner listing pagination.
* Enum usage: None yet; could add `CapsuleVisibility` if later more granular (e.g., friends-only).
* Referential actions: Likely default (cascade delete). Deleting User should cascade to Capsules — verify to avoid orphans & enforce storage cleanup (hook needed).
* Transactions: Multi-step flows (e.g. future versioning + audit insert) will require `$transaction` to maintain atomicity.
* Migration naming: Date-time prefixed for deterministic ordering; ensures replay reliability across environments.

Optimization idea: Add partial index for public capsules filtering `WHERE isPublic = true` to accelerate public listing if table grows large.

## 21. Authentication Internals
JWT Access Token Payload Structure:
```
{
  sub: <userId>,
  email: <user email>,
  iat: <issued at epoch>,
  exp: <expiry epoch>
}
```
Implementation currently uses custom keys (maybe `userId`); recommending aligning to JWT best practice (`sub`). Strategy maps payload to `req.user`. Refresh tokens (current plain text) will migrate to:
1. Generate random 256-bit value.
2. Hash with bcrypt (cost moderate to avoid login latency) or argon2.
3. Store hash + expiry timestamp.
4. On refresh request: compare hash constant time; rotate (issue new token & hash, delete old). This mitigates replay; stolen old refresh token invalid after use.

Revocation scenarios: Manual admin logout (set hash null), global sign-out (increment user token version; embed version claim in JWT; reject mismatched versions).

## 22. Storage Driver Interface Contract
Implicit interface (could be formalized via TypeScript interface):
```
storeCapsuleImages(files: Express.Multer.File[], opts: { userId: number }): Promise<StoredImageMeta[]>;
```
Where `StoredImageMeta` currently is simplified to just URL strings array. Evolving shape:
```
{
  key: string;        // canonical object key (future)
  url: string;        // resolved (maybe signed) URL
  bytes: number;      // size for quota/tracking
  mime: string;       // media type
  hash?: string;      // integrity (sha256)
}
```
Local driver responsibilities: ensure directories, collision-safe filenames, atomic write (fs writeFile is atomic for small files on most FS; large writes may not be). Supabase driver responsibilities: handle network errors (retry with exponential backoff), differentiate permanent vs transient errors.

## 23. Error & Exception Flow
Current state: Relying on Nest default exception layer. Planned enhancements:
* Global Exception Filter: Map Prisma unique constraint (P2002) → 409 Conflict with field list.
* Validation errors standardized: `{ code: 'VALIDATION_FAILED', errors: [{ field, constraints[] }] }`.
* Logging Interceptor (exists) extended to include request ID correlation (UUID per request) attached via middleware.
* Retry semantics: Certain storage transient failures (HTTP 5xx) trigger limited retries inside StorageService.

## 24. Performance & Scaling Considerations
Baseline scaling strategies:
* Horizontal scaling: Stateless app nodes behind load balancer; shared DB + object storage.
* File uploads memory usage: Each file fully buffered currently — risk at scale. Mitigation: enforce per-request total size limit & move to streaming (pipe to temp or directly to storage) later.
* DB query optimization: Pagination with `(createdAt, id)` composite cursor to ensure stable ordering; reduces offset scan cost for deep pages.
* Caching layer: Public capsule listing cache (key: page+filters) in Redis with short TTL (e.g., 30s) once traffic grows.
* Rate limiting: Token bucket per IP & per user ID to shield expensive endpoints (uploads).
* N+1 avoidance: Relations included judiciously; no dynamic loops performing queries presently.

Rough request cost model (Supabase driver):
* CPU: JWT verify negligible; hashing (on login) moderate.
* IO: Network to Supabase storage dominant for images; DB insert minor.
* Memory: Sum(filesizes) per concurrent upload request; set sensible max (e.g., 20MB).

## 25. Security Threat Model (Initial)
Assets:
* User credentials & refresh tokens
* Time-locked content (confidential pre-unlock)
* Service role key

Threats & Mitigations:
* Brute force login → rate limiting, progressive backoff (pending).
* Token theft (XSS risk) → Advise frontend to store tokens in memory (not localStorage) or use httpOnly cookie transport strategy.
* Bucket enumeration → Switch to private bucket + signed URLs (roadmap).
* Replay of refresh token → Rotation & hashing.
* Unauthorized early access to locked capsule → Ensure no alternate API leaks content; guard any new endpoints & avoid logging sensitive content.
* Supply chain (npm) → Use lockfile, periodic `npm audit` with triage.
* Data integrity corruption → Introduce per-image SHA256 hashes stored in DB for periodic audit.

## 26. Observability Plan
Planned pillars:
* Structured Logging: Use pino or Winston with JSON output (fields: timestamp, level, msg, requestId, userId, latencyMs).
* Metrics: Expose `/metrics` (Prometheus) capturing request rate, error rate, storage upload latency histogram, DB query durations.
* Tracing: OpenTelemetry instrumentation for request span + DB + storage sub-spans. Export to OTLP collector.
* Alerting: SLO (e.g., <1% 5xx over 5m) breach triggers page.

## 27. Data Retention & Deletion Semantics
Current: Hard delete for capsules => metadata gone, images orphaned (cleanup TODO).
Planned:
* Soft delete flag (`deletedAt`) enabling recovery & audit.
* Lifecycle job scanning for soft-deleted >30d → permanent purge (delete storage objects + row).
* GDPR compliance: User deletion cascades (verify & scrub logs of personal data where feasible by decoupling PII from logs— store userId only, resolve externally when needed).

## 28. Redundancy & Long-term Preservation Blueprint
Objective: Ensure capsule content & metadata remain accessible over decades despite platform drift, bit rot, or vendor lock-in.
Components:
1. Multi-Region Replication: Write images to primary (Supabase) and asynchronously replicate to secondary object store (e.g., AWS S3 / Backblaze B2). Use outbox table with status for eventual consistency.
2. Integrity Hashing: Compute SHA256 for each stored object; store in DB. Scheduled job periodically re-downloads random sample verifying hash, raising alert on mismatch (bit rot detection).
3. Erasure Coding (Future): Instead of full duplication, optional use of Reed-Solomon fragments stored across providers, reconstructible even if subset lost.
4. Schema Versioning: Add `schemaVersion` field to Capsule. Migration layer transforms legacy records on read or in background batch when upgrading data structure.
5. Export Format: Periodic generation of WARC-like archive bundles (JSON metadata + binary blobs) enabling cold storage offline preservation.
6. Time-Unlock Assurance: Store unlock schedule redundantly; optional signing of unlock events with server key to produce audit log chain (hash-linked) proving unlock chronology.
7. Disaster Recovery Drills: Document recovery procedure; automated test restoring latest backup into staging environment monthly.

Implementation Phases:
Phase 1: Add hash + secondary replica write (best-effort). Phase 2: Background verifier. Phase 3: Export pipeline. Phase 4: Signed event log. Phase 5: Optional erasure coding.

## 29. Testing Strategy & Current Gaps
Current tests: Minimal e2e skeleton. Needed layers:
* Unit: AuthService (hash, validation), CapsulesService (lock logic), StorageService (driver selection stubbed IO).
* Integration: Prisma with test DB (dockerized Postgres) applying migrations; verify create → list ordering, masking correctness.
* E2E: Register → login → create capsule (locked/unlocked) → verify public listing masking.
* Property-based tests: Lock logic around boundary times (just before / after unlockAt) to ensure no off-by-one.
* Fault injection: Simulate storage failure (throw) ensure capsule still created or transactionally aborted per policy decision.

## 30. Deployment & CI/CD Outline
Pipeline (proposed):
1. Push → GitHub Actions workflow.
2. Steps: Install deps (with cache) → Lint → Type check → Unit tests → Build → Run Prisma migrate diff validation.
3. On main branch success: Build Docker image (multi-stage: build then minimal runtime) tagging with commit SHA.
4. Deploy: Push image to registry; trigger infra (e.g., Render / Fly.io / AWS ECS) rollout.
5. Post-deploy smoke: Hit `/health` endpoint (to be added) verifying DB connectivity + storage driver readiness.

Secrets management: Use platform secret store; never bake secrets into image. Key rotation done by updating secret & redeploying (JWT secret rotation requires dual-secret support window— implement via key id header `kid`).

## 31. Configuration Matrix (Dev vs Prod)
| Concern | Dev | Prod |
|---------|-----|------|
| DB | Local (or Supabase test) | Supabase production |
| Storage | Local filesystem | Supabase bucket |
| Logging | Verbose (debug) | Info + structured |
| CORS | Wide (localhost frontends) | Restricted (prod domain) |
| Auth secrets | .env.dev weak placeholder | Strong secrets in secret store |
| Error detail | Stack traces returned | Sanitized, logged internally |
| Metrics | Optional | Mandatory |

## 32. Known Edge Cases & Race Conditions
* Simultaneous update & unlock boundary: If request arrives exactly at unlockAt threshold, time arithmetic may differ by milliseconds; treat `>=` now as unlocked to avoid flicker.
* Duplicate image filenames (local driver): Random suffix mitigates; still theoretical collision extremely low (improve with UUID v4).
* Partial storage failure: Some images succeed, others fail; user sees subset. Could roll back by deleting uploaded subset & raising error (future transaction-like semantics).
* User deletion while creating capsule: If cascade, capsule create may fail with FK constraint mid-flight after user removed; mitigate by checking existence at service start or using transaction with deferred constraints.
* Clock skew across replicated regions (future): Use UTC from single reliable source; avoid relying on DB NOW() vs app Date mixes without consistency.

## 33. Glossary
* Capsule: A time-locked content container containing textual `content`, optional `images`, visibility flag, and an unlock datetime.
* Driver (storage): Pluggable implementation deciding how binary objects are persisted.
* Lock/Unlock: State gating content visibility based on current time vs `unlockAt`.
* Masking: Technique of returning schema-compatible but sanitized fields for locked/public capsules.
* Outbox Pattern: Reliable event dispatch pattern using a DB table ensuring at-least-once processing.
* Erasure Coding: Data protection method splitting data into fragments with redundancy (reconstructible with subset).
* Signed URL: Time-limited tokenized URL granting temporary access to private object.

---
This extended expansion adds deep architectural, operational, and future-proofing detail suitable for thesis-level documentation and sets a concrete blueprint for forthcoming redundancy and preservation features.